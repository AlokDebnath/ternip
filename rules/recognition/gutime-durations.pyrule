#!/usr/bin/env python

import re
import ternip
import ternip.rule_engine.rule

class rule(ternip.rule_engine.rule.rule):
    """
    The duration rules from GUTime require special pre and postprocessing to the
    string
    """
    
    id = 'gutime-durations'
    after = []
    
    _rule_exps = [
        r'(<(\d+|NUM_START.*?NUM_END)(-(second|minute|hour|day|month|year|week|decade|centur(y|ie)|milleni(um|a))(-old)?)?~.+>|<(\d+|NUM_START.*?NUM_END)~.+>)(<(second|minute|hour|day|month|year|week|decade|centur(y|ie)|milleni(um|a))(-old)?~.+>(<old~.+>)?)?',
        r'<the~.+><([pl]ast|next)~.+><(\d+|NUM_START.*?NUM_END)~.+><(second|minute|hour|day|month|year|week|decade|centur(y|ie)|milleni(um|a))s?~.+>',
        r'<another~.+><(\d+|NUM_START.*?NUM_END)~.+><(second|minute|hour|day|month|year|week|decade|centur(y|ie)|milleni(um|a))s?~.+>',
        r'<the~.+><(\d+|NUM_START.*?NUM_END)~.+><(second|minute|hour|day|month|year|week|decade|centur(y|ie)|milleni(um|a))s?~.+>',
        r'<the~.+><(NUM_ORD_STARTfirstNUM_ORD_END|initial|last|final)~.+>(<(\d+|NUM_START.*?NUM_END)~.+>)<(second|minute|hour|day|month|year|week|decade|centur(y|ie)|milleni(um|a))s?~.+>',
        r'<the~.+><(((\d*)(1st|2nd|3rd|[4567890]th))|NUM_ORD_START.+?NUM_ORD_END)~.+><(straight|consecutive)~.+><(second|minute|hour|day|month|year|week|decade|centur(y|ie)|milleni(um|a))~.+>((<in~.+><a~.+><row~.+>|<consecutively~.+>))?',
        r'<the~.+><(((\d*)(1st|2nd|3rd|[4567890]th))|NUM_ORD_START.+?NUM_ORD_END)~.+><(second|minute|hour|day|month|year|week|decade|centur(y|ie)|milleni(um|a))~.+>(<straight~.+>|<consecutively~.+>|<in~.+><a~.+><row~.+>)',
        r'<no~.+><more~.+><than~.+><(\d+|NUM_START.*?NUM_END)~.+><(second|minute|hour|day|month|year|week|decade|centur(y|ie)|milleni(um|a))s?~.+>',
        r'<more~.+><than~.+><(\d+|NUM_START.*?NUM_END)~.+><(second|minute|hour|day|month|year|week|decade|centur(y|ie)|milleni(um|a))s?~.+>',
        r'<at~.+><least~.+><(\d+|NUM_START.*?NUM_END)~.+><(second|minute|hour|day|month|year|week|decade|centur(y|ie)|milleni(um|a))s?~.+>',
        r'<(\d+|NUM_START.*?NUM_END)~.+><(second|minute|hour|day|month|year|week|decade|centur(y|ie)|milleni(um|a))s?~.+>',
        r'<a~.+>(<(few|couple|couple~.+><of)~.+>)?<(second|minute|hour|day|month|year|week|decade|centur(y|ie)|milleni(um|a))s?~.+>'
    ]
    
    _number_term = r'(one|two|three|four|five|six|seven|eight|nine|ten|eleven|twelve|thirteen|fourteen|fifteen|sixteen|seventeen|eighteen|nineteen|twenty|thirty|forty|fifty|sixty|seventy|eighty|ninety|hundred|thousand|million|billion|trillion|first|second|third|fourth|fifth|sixth|seventh|eighth|ninth|tenth|eleventh|twelfth|thirteenth|fourteenth|fifteenth|sixteenth|seventeenth|eighteenth|nineteenth|twentieth|thirtieth|fortieth|fiftieth|sixtieth|seventieth|eightieth|ninetieth|hundreth|thousandth|millionth|billionth|trillionth)'
    _ord_unit_nums = r'(first|second|third|fourth|fifth|sixth|seventh|eighth|ninth)'
    _ord_other_nums = r'(tenth|eleventh|twelfth|thirteenth|fourteenth|fifteenth|sixteenth|seventeenth|eighteenth|nineteenth|twentieth|thirtieth|fortieth|fiftieth|sixtieth|seventieth|eightieth|ninetieth|hundreth|thousandth|millionth|billionth|trillionth)'
    _higher_nums = r'(hundred|thousand|million|billion|trillion)'
    _unit_nums = r'(one|two|three|four|five|six|seven|eight|nine)'
    _unique_nums = r'(ten|eleven|twelve|thirteen|fourteen|fifteen|sixteen|seventeen|eighteen|nineteen)'
    _tens_nums = r'(twenty|thirty|forty|fifty|sixty|seventy|eighty|ninety)'
    
    def __init__(self):
        rules = []
        for exp in self._rule_exps:
            rules.append(re.compile(self._prep_re(exp), re.IGNORECASE))
        self._rules = rules
    
    def _deliminate_numbers(self, sent):
        """
        Translation of GUTime function 'deliminateNumbers' - marks up number
        sequences
        """
        
        rest = sent
        sent = ''
        previous_word = ''
        current_word = ''
        
        in_number = False
        
        while re.search(r'<[a-zA-Z-]+~.+?>', rest):
            m = re.search(r'<(?P<word>[a-zA-Z-]+)~(?P<pos>.+?)>', rest)
            sent += m.string[:m.start()]
            rest = m.string[m.end():]
            
            current_word = m.group('word')
            
            # Get next word
            n = re.search(r'<(?P<word>[a-zA-Z-]+)~(?P<pos>.+?)>', rest)
            if n != None:
                next_word = n.group('word')
            else:
                next_word = ''
            
            # the following deals reasonably well with hypenated numbers like "twenty-one"
            if re.match(self._number_term + '(-' + self._number_term + ')*', current_word, re.I) != None:
                # This current word is identified as a number
                if not in_number:
                    # first in (possible) series of numbers
                    to_add = '<NUM_START' + m.group('word') + '~' + m.group('pos') + '>'
                    in_number = True
                else:
                    # either not first in series, or between ordinal and regular nums (i.e. "first two")
                    if (re.search(self._ord_unit_nums + r'$', previous_word) != None) or (re.search(self._ord_other_nums + r'$', previous_word) != None):
                        # between ordinal and regular
                        sent = re.sub(r'(NUM_START(.*?))$', 'NUM_ORD_START\2', sent) # replace with NUM_ORD_START
                        sent = re.sub(r'(~.+?>)$', 'NUM_ORD_END\1', sent)
                        to_add = '<NUM_START' + m.group('word') + '~' + m.group('pos') + '>'
                    else:
                        # number is continuing
                        to_add = '<' + m.group('word') + '~' + m.group('pos') + '>'
            
            else:
                # current word is not a number
                if in_number:
                    # previous word was a number
                    # following works fairly well...it avoids marking things like "six and two" as a single
                    # number while still marking things like "two hundred and one" as a single number
                    if (current_word.lower() == 'and') and \
                       (re.search(self._higher_nums, previous_word, re.I) != None) and \
                       ((re.search(self._unit_nums, next_word, re.I) != None) or \
                        (re.search(self._unique_nums, next_word, re.I) != None) or \
                        (re.search(self._tens_nums+'(-'+self._unit_nums+'|'+self._ord_unit_nums+')?', next_word, re.I) != None) or \
                        (re.search(self._ord_unit_nums, next_word, re.I) != None) or \
                        (re.search(self._ord_other_nums, next_word, re.I) != None)):
                        to_add = '<' + m.group('word') + '~' + m.group('pos') + '>'
                    else:
                        # number doesn't continue
                        in_number = False
                        if (re.search(self._ord_unit_nums + '$', previous_word) != None) or (re.search(self._ord_other_nums + '$', previous_word) != None):
                            sent = re.sub(r'(NUM_START(.*?))$', 'NUM_ORD_START\2', sent) # replace with NUM_ORD_START
                            sent = re.sub(r'(~.+?>)$', 'NUM_ORD_END\1', sent)
                        else:
                            sent = re.sub(r'(~.+?>)$', 'NUM_END\1', sent)
                        to_add = '<' + m.group('word') + '~' + m.group('pos') + '>'
                else:
                    to_add = '<' + m.group('word') + '~' + m.group('pos') + '>'
            
            sent += to_add
            previous_word = current_word
        
        if re.match(self._number_term + '(-' + self._number_term + ')*', current_word, re.I) != None:
            # final word is a number
            sent = re.sub(r'(~.+?>)$', 'NUM_END\1', sent)
        
        sent += rest
        return sent
    
    def apply(self, sent):
        
        # Convert to string and add number boundary markers
        senttext = self._deliminate_numbers(self._toks_to_str(sent))
        
        success = False
        for rule in self._rules:
            for match in rule.finditer(senttext):
                # This is a somewhat quick fix to the problem where in the pattern finding, $numString will include
                #   something like "NUM_START...NUM_END......NUM_START...NUM_END", with the first NUM_START and the last
                #   NUM_END supposedly enclosing just one number, when obviously that's not the case...this ends up screwing
                #   up the expressionToDuration function.
                # PROBLEM - This does create a problem with the case of "the first five minutes", because "first" ends up
                #   getting tags around it, which gets stopped here...this doesn't create a terrible problem, but
                #   it should still be fixed
                if re.search(r'(NUM_START|NUM_ORD_START).+(NUM_START|NUM_ORD_START)', match.group()):
                    continue
                
                # okay, first we need to find which tokens we matched, can do this
                # by using our token markers
                ti = senttext.count('<', 0, match.start())
                tj = senttext.count('<', 0, match.end())
                
                # New TIMEX
                t = ternip.timex('duration')
                
                for i in range(len(sent)):
                    # now get all tokens in the range and add the new timex if needed
                    (token, pos, ts) = sent[i]
                    if i >= ti and i < tj:
                        ts.add(t)
                    
                    sent[i] = (token, pos, ts)
                    success = True
        
        return (sent, success)